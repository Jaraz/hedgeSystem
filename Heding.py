# -*- coding: utf-8 -*-
"""
Created on Mon Jan 12 19:19:16 2015

@author: jaycw_000
"""

from __future__ import division
import math
from matplotlib.pyplot import *
import numpy
import Random
from IPython.parallel import Client
import securities
import optFuncs
import pickle
import dill

from types import FunctionType
from IPython.utils.pickleutil import can_map
from IPython.kernel.zmq import serialize

x = 10

can_map.pop(FunctionType, None)
serialize.pickle = pickle


def runHedgeSimul(S, T, port, r, volFunc, path, hedgeType, debugFlag):
    pnl = 0
    s_old = S
    s_new = S
    
    hedgeT = 0
    hedgeTm1 = 0

    numSteps = len(path)
    
    #print "Path:", path
    
    for i in xrange(0, numSteps):
        expiry = T * (1 - i/numSteps)
        time = T - expiry
        port.updateExpiry(expiry)

        vol = volFunc(time, 1/numSteps)
        
        hedge = hedgeType.returnHedge(s_new, r, vol, port)
        
        #MTM of gamma hedge
        if hedge[1] <> 0:                
            atmHedge = securities.call(s_new, expiry, hedge[1])
            atmPort = securities.portfolio([atmHedge])
            hedgeTm1 = optFuncs.calcPrice(s_new, r, vol, atmPort)
        
        s_old = s_new
        s_new = path[i]
    
        if hedge[1] <> 0:
            if i < numSteps-1:        
                atmPort.updateExpiry(T * (1 - (i+1)/numSteps))
                hedgeT = optFuncs.calcPrice(s_new, r, vol, atmPort)            
            else:
                hedgeT = optFuncs.calcPayoff(s_new, atmPort)
         
        if debugFlag == True: 
            print "Step: ", i
            print "s t-1: ", s_old
            print "s t: ", s_new
            print "hedges: ", hedge
            print "hedgeTm1: ", hedgeTm1
            print "hedge: ", hedgeT
            print "stock pnl: ", hedge[0] * (s_new - s_old)
            print "gamma pnl: ", hedgeT - hedgeTm1
            print " "
                    
        #PnL from delta hedging
        pnl += hedge[0] * (s_new - s_old)
        
        #PnL from gamma hedging
        if hedge[1] <>0:
            pnl += hedgeT - hedgeTm1

    optionPayoff = optFuncs.calcPayoff(s_new, port)
    pnl = pnl + optionPayoff
    
    return pnl    

class gbmPathEngine:
    def __init__(self):
        self.rnd = Random.randMC(True,False)

    def eulerPath(self, T, S, mu, r, vol, numSteps, numPaths):
        delta_t = T / numSteps

        answer = numpy.zeros([numPaths, numSteps])
        randNumbers = numpy.zeros([numPaths, numSteps])
        
        randNumbers = self.rnd.genNormalMatrix(numPaths * numSteps, numPaths, numSteps)
        
        volDeltaT = vol * math.sqrt(delta_t)        
        
        for j in xrange(numPaths):
            volDeltaRand = randNumbers[j] * volDeltaT
            
            term = 1.0 + mu * delta_t + volDeltaRand
    
            s_next = 0
            s_last = S
    
            for i in xrange(0,numSteps):
                s_next = s_last * term[i]
                s_last = s_next
                answer[j, i] = s_next
    
        return answer
        

 #path generated by dterministic vol function
class gbmPathVolEngine(gbmPathEngine):
    def __init__(self, volFunc):
        self.volFunc = volFunc
        self.rnd = Random.randMC(True,False)
    
    def eulerPath(self, T, S, mu, r, vol, numSteps, numPaths):
        delta_t = T / numSteps
        
        answer = numpy.zeros([numPaths, numSteps])
        randNumbers = numpy.zeros([numPaths, numSteps])
        
        randNumbers = self.rnd.genNormalMatrix(numPaths * numSteps, numPaths, numSteps)
        
        sqrtDeltaT = math.sqrt(delta_t)        
        
        for j in xrange(numPaths):
            DeltaRand = randNumbers[j] * sqrtDeltaT
            
            term = 1.0 + mu * delta_t 
    
            s_next = 0
            s_last = S
    
            for i in xrange(0,numSteps):
                time = i * delta_t 
                volRMS = self.volFunc(time,delta_t)
                s_next = s_last * (term + DeltaRand[i] * volRMS)
                s_last = s_next
                answer[j, i] = s_next
    
        return answer    

class gbmExactPathEngine(gbmPathEngine):
    

def evoVol(t, dt):

    def tempFunc(t):
        #return 0.1**2 * t
        return (0.1 * math.sqrt(3))**2 * (t**3) / 3
    
    return math.sqrt(1 / dt * (tempFunc(t + dt) - tempFunc(t))) 

#returns vol to use for given t, t is expiry
def testVol(t, dt):

    def tempFunc(t):
        return 0.1**2 * t
        return (0.1 * math.sqrt(3))**2 * (t**3) / 3
    
    return math.sqrt(1 / dt * (tempFunc(t + dt) - tempFunc(t)))

def testVol2(t, dt):
    return 0.1 * math.sqrt(3) * (t+0.001)

#returns an array for gamma hedging
class hedger:
    def __init__(self, gammaFlag):
        self.gammaHedge = gammaFlag
    
    def returnHedge(self, S, r, vol, portfolio):
       
        if(S > K):
            return numpy.array([-1,0]);
        else:
            return numpy.array([0,0]);
   
class bsHedger(hedger):
    def returnHedge(self, S, r, vol, port):
        bsGamma = 0

        #newPort = copy.deepcopy(port)
        newPort = securities.portfolio(port.returnSec())

        if self.gammaHedge == True:
            portGamma = optFuncs.calcGamma(S, r, vol, port)
            atmGamma = optFuncs.optionGamma(port.returnExpiry(), S, "call", S, r, vol)
            bsGamma = -portGamma / atmGamma        
            newSec = securities.call(S, port.returnExpiry(), bsGamma)
            
            #newPort.addSec([newSec])
            newPort.opt = port.opt + [newSec]
        
        bsDelta = -optFuncs.calcDelta(S, r, vol, newPort)
        
        return numpy.array([bsDelta,bsGamma])

class hedgeSimul:
    def __init__(self, S, mu, r, volFunc, portfolio, debugFlag, multiFlag):
        self.S = S
        self.port = portfolio
        self.secList = portfolio.returnSec()
        self.T = self.secList[0].returnExpiry()
        self.mu = mu
        self.r = r
        self.volFunc = volFunc
        self.debugFlag = debugFlag
        self.hedgeType = hedger
        self.multiCore = multiFlag
        
        
    def setMu(self, x):
        self.mu = x
    
    def setVol(self,x):
        self.volFunc = x
    
    def runSim(self, numSteps, numSims, pathEngine, hedger):
        stats = []
        self.hedgeType = hedger
        path = pathEngine.eulerPath(self.T, self.S, self.mu, self.r, self.volFunc, numSteps, numSims)

        myLambdaFunc = lambda path: runHedgeSimul(S, T, port, r, vol, path, hedgeType, debugFlag)

        S = self.S
        T = self.T
        r = self.r
        vol = self.volFunc
        port = self.port
        hedgeType = self.hedgeType
        debugFlag = self.debugFlag

        if self.multiCore == True:
            clients = Client()
            clients[:].use_dill()
            lview = clients.load_balanced_view()
            dview = clients[:]        
    
            with dview.sync_imports():
                import numpy
                import securities
                import optFuncs
                import math
    
            dview.push(dict(runHedgeSimul = runHedgeSimul))     
    
            myDict = dict(S = S, T = T, r = r, vol = vol, port = port, hedgeType = hedgeType, debugFlag = debugFlag)
            dview.push(myDict)
    
            lview.block = True
    
            stats = lview.map(myLambdaFunc, path)
        else:
            stats = map(myLambdaFunc, path)
        
        return stats
        

def conf_int_native(x, ci=0.95):
    ci2 = (1-ci)*.5
    low_idx = int(ci2*x.size)
    high_idx = int((1-ci2)*x.size)
    x.sort()
    return x.mean(), x[low_idx], x[high_idx]


#main

MCengine = gbmPathEngine()
detVolEngine = gbmPathVolEngine(evoVol)
hdgrDelta = bsHedger(False)
hdgrGamma = bsHedger(True)
callOption = securities.call(100, 1, 100)
callATM = securities.callDigital(100, 1, 100)
numSims = 1

secList = [callOption]
port1 = securities.portfolio(secList)

simSingle = hedgeSimul(100, 0.0, 0.0, testVol, port1, True, False)
simMulti = hedgeSimul(100, 0.0, 0.0, testVol, port1, False, True)
    
#test = numpy.array(simSingle.runSim(40, numSims, MCengine, hdgrDelta))
test = numpy.array(simSingle.runSim(2, numSims, detVolEngine, hdgrDelta))
print "PnL = ", sum(test)/numSims
print "sd = ", numpy.std(test)
print "conf = ", conf_int_native(test)

##hist(test)
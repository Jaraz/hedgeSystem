# -*- coding: utf-8 -*-
"""
Created on Mon Jan 12 19:19:16 2015

@author: jaycw_000
"""

from __future__ import division
import math
from matplotlib.pyplot import *
import numpy
import Random
from IPython.parallel import Client
import securities
import optFuncs
import pickle
import dill
import scipy

from types import FunctionType
from IPython.utils.pickleutil import can_map
from IPython.kernel.zmq import serialize

x = 10

can_map.pop(FunctionType, None)
serialize.pickle = pickle


def runHedgeSimul(S, T, port, r, volFunc, path, hedgeType, debugFlag):
    pnl = 0
    s_old = S
    s_new = S
    
    hedgeT = 0
    hedgeTm1 = 0

    numSteps = len(path)
    
    #print "Path:", path
    
    for i in xrange(0, numSteps):
        expiry = T * (1 - i/numSteps)
        timeToEnd = T - expiry
        port.updateExpiry(expiry)

        #vol = volFunc(timeToEnd, 1/numSteps)
        vol = volFunc(timeToEnd, expiry)
        
        hedge = hedgeType.returnHedge(s_new, r, vol, port)
        
        #MTM of gamma hedge
        if hedge[1] <> 0:                
            atmHedge = securities.call(s_new, expiry, hedge[1])
            atmPort = securities.portfolio([atmHedge])
            hedgeTm1 = optFuncs.calcPrice(s_new, r, vol, atmPort)
        
        s_old = s_new
        s_new = path[i]
    
        if hedge[1] <> 0:
            if i < numSteps-1:        
                atmPort.updateExpiry(T * (1 - (i+1)/numSteps))
                hedgeT = optFuncs.calcPrice(s_new, r, vol, atmPort)            
            else:
                hedgeT = optFuncs.calcPayoff(s_new, atmPort)
         
        if debugFlag == True: 
            print "Step: ", i
            print "s t-1: ", s_old
            print "s t: ", s_new
            print "hedges: ", hedge
            print "hedgeTm1: ", hedgeTm1
            print "hedge: ", hedgeT
            print "stock pnl: ", hedge[0] * (s_new - s_old)
            print "gamma pnl: ", hedgeT - hedgeTm1
            print " "
                    
        #PnL from delta hedging
        pnl += hedge[0] * (s_new - s_old)
        
        #PnL from gamma hedging
        if hedge[1] <>0:
            pnl += hedgeT - hedgeTm1

    optionPayoff = optFuncs.calcPayoff(s_new, port)
    pnl = pnl + optionPayoff
    
    return pnl    

class gbmPathEngine:
    def __init__(self):
        self.rnd = Random.randMC(True,False)

    def eulerPath(self, T, S, mu, r, vol, numSteps, numPaths):
        delta_t = T / numSteps

        answer = numpy.zeros([numPaths, numSteps])
        randNumbers = numpy.zeros([numPaths, numSteps])
        
        randNumbers = self.rnd.genNormalMatrix(numPaths * numSteps, numPaths, numSteps)
        
        volDeltaT = vol * math.sqrt(delta_t)        
        
        for j in xrange(numPaths):
            volDeltaRand = randNumbers[j] * volDeltaT
            
            term = 1.0 + mu * delta_t + volDeltaRand
    
            s_next = 0
            s_last = S
    
            for i in xrange(0,numSteps):
                s_next = s_last * term[i]
                s_last = s_next
                answer[j, i] = s_next
    
        return answer
        

 #path generated by dterministic vol function
class gbmPathVolEngine(gbmPathEngine):
    def __init__(self, volFunc):
        self.volFunc = volFunc
        self.rnd = Random.randMC(True,False)
    
    def eulerPath(self, T, S, mu, r, vol, numSteps, numPaths):
        delta_t = T / numSteps
        
        answer = numpy.zeros([numPaths, numSteps])
        randNumbers = numpy.zeros([numPaths, numSteps])
        
        randNumbers = self.rnd.genNormalMatrix(numPaths * numSteps, numPaths, numSteps)
        
        sqrtDeltaT = math.sqrt(delta_t)        
        
        for j in xrange(numPaths):
            DeltaRand = randNumbers[j] * sqrtDeltaT
            
            term = 1.0 + mu * delta_t 
    
            s_next = 0
            s_last = S
    
            for i in xrange(0,numSteps):
                time = i * delta_t 
                volRMS = self.volFunc(time,delta_t)
                s_next = s_last * (term + DeltaRand[i] * volRMS)
                s_last = s_next
                answer[j, i] = s_next
    
        return answer    

class gbmExactPathEngine(gbmPathEngine):
    def __init__(self, volFunc):
        self.volFunc = volFunc        
        self.rnd = Random.randMC(True, False)
    
    def eulerPath(self, T, S, mu, r, vol, numSteps, numPaths):
        delta_t = T / numSteps
        answer = numpy.zeros([numPaths, numSteps])
        randNumbers = numpy.zeros([numPaths, numSteps])

        randNumbers = self.rnd.genNormalMatrix(numPaths * numSteps, numPaths, numSteps)        
        
        for j in xrange(numPaths):
            deltaRand = randNumbers[j] * math.sqrt(delta_t)
                        
            s_next = 0
            s_last = S
            for i in xrange(numSteps):
                timeToEnd = i * delta_t
                volRMS = self.volFunc(timeToEnd, delta_t)
                
                term1 = (mu - 0.5 * volRMS**2)*delta_t
                term2 = volRMS * deltaRand[i]                
                
                s_next = s_last * math.exp(term1 + term2)
                s_last = s_next
                answer[j, i] = s_next
        
        return answer

def optionPayoff(vec, strike):
    answer = 0
    test = vec[0].size - 1
    print test
    for i in xrange(len(vec)):
        answer = answer + max(vec[i][test] - strike,0)
    return answer / len(vec)

#return RMS vol
def rmsVol(t, dt):
    integral = scipy.integrate.quad(stepVol, t, t+dt)[0]
    return math.sqrt(1/dt * integral)
    
#variance
def stepVol(t):
    answer = 0
    if t<0.5:
        answer =  0.05
    if t>=0.5:
        answer =  0.1323
    return answer**2

#returns vol to use for given t, t is expiry
def testVol(t, dt):
    return rmsVol(t,t+dt)
    
    def tempFunc(t):
        return 0.1**2 * t
        #return (0.1 * math.sqrt(3))**2 * (t**3) / 3
    
    return math.sqrt(1 / dt * (tempFunc(t + dt) - tempFunc(t)))


#returns an array for gamma hedging
class hedger:
    def __init__(self, gammaFlag):
        self.gammaHedge = gammaFlag
    
    def returnHedge(self, S, r, vol, portfolio):
       
        if(S > K):
            return numpy.array([-1,0]);
        else:
            return numpy.array([0,0]);
   
class bsHedger(hedger):
    def returnHedge(self, S, r, vol, port):
        bsGamma = 0

        newPort = securities.portfolio(port.returnSec())

        if self.gammaHedge == True:
            portGamma = optFuncs.calcGamma(S, r, vol, port)
            atmGamma = optFuncs.optionGamma(port.returnExpiry(), S, "call", S, r, vol)
            bsGamma = -portGamma / atmGamma        
            newSec = securities.call(S, port.returnExpiry(), bsGamma)
            
            newPort.opt = port.opt + [newSec]
        
        bsDelta = -optFuncs.calcDelta(S, r, vol, newPort)
        
        return numpy.array([bsDelta,bsGamma])

class hedgeSimul:
    def __init__(self, S, mu, r, volFunc, portfolio, debugFlag, multiFlag):
        self.S = S
        self.port = portfolio
        self.secList = portfolio.returnSec()
        self.T = self.secList[0].returnExpiry()
        self.mu = mu
        self.r = r
        self.volFunc = volFunc
        self.debugFlag = debugFlag
        self.hedgeType = hedger
        self.multiCore = multiFlag
        
        
    def setMu(self, x):
        self.mu = x
    
    def setVol(self,x):
        self.volFunc = x
    
    def runSim(self, numSteps, numSims, pathEngine, hedger):
        stats = []
        self.hedgeType = hedger
        path = pathEngine.eulerPath(self.T, self.S, self.mu, self.r, self.volFunc, numSteps, numSims)

        myLambdaFunc = lambda path: runHedgeSimul(S, T, port, r, vol, path, hedgeType, debugFlag)

        S = self.S
        T = self.T
        r = self.r
        vol = self.volFunc
        port = self.port
        hedgeType = self.hedgeType
        debugFlag = self.debugFlag

        if self.multiCore == True:
            clients = Client()
            clients[:].use_dill()
            lview = clients.load_balanced_view()
            dview = clients[:]        
    
            with dview.sync_imports():
                import numpy
                import securities
                import optFuncs
                import math
                import scipy
    
            dview.push(dict(runHedgeSimul = runHedgeSimul))  
            dview.push(dict(stepVol = stepVol))
            dview.push(dict(rmsVol = rmsVol))
    
            myDict = dict(S = S, T = T, r = r, vol = vol, port = port, hedgeType = hedgeType, debugFlag = debugFlag)
            dview.push(myDict)
    
            lview.block = True
    
            stats = lview.map(myLambdaFunc, path)
        else:
            stats = map(myLambdaFunc, path)
        
        return stats
        

def conf_int_native(x, ci=0.95):
    ci2 = (1-ci)*.5
    low_idx = int(ci2*x.size)
    high_idx = int((1-ci2)*x.size)
    x.sort()
    return x.mean(), x[low_idx], x[high_idx]


#main
detVolEngine = gbmExactPathEngine(rmsVol)
hdgrDelta = bsHedger(False)
hdgrGamma = bsHedger(True)

callOption = securities.call(100, 1, 100)
secList = [callOption]
port1 = securities.portfolio(secList)

simSingle = hedgeSimul(100, 0.0, 0.0, testVol, port1, False, False)
simMulti = hedgeSimul(100, 0.0, 0.0, testVol, port1, False, True)

numSims = 100
test = numpy.array(simMulti.runSim(400, numSims, detVolEngine, hdgrDelta))
print "PnL = ", sum(test)/numSims
print "sd = ", numpy.std(test)
print "conf = ", conf_int_native(test)

##hist(test)